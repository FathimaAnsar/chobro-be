// User Controller
const userController = {
  // Authentication methods
  async register(req, res, next) {
    try {
      const { email, password, firstName, lastName, phoneNumber, accountType } = req.body;
      
      // Check if user already exists
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(400).json({ message: 'User already exists with this email' });
      }
      
      // Hash password
      const hashedPassword = await bcrypt.hash(password, 10);
      
      // Create user
      const user = new User({
        email,
        password: hashedPassword,
        firstName,
        lastName,
        phoneNumber,
        accountType
      });
      
      await user.save();
      
      // Generate tokens
      const { accessToken, refreshToken } = generateTokens(user);
      
      // Return user data and tokens
      res.status(201).json({
        user: {
          id: user._id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          accountType: user.accountType
        },
        accessToken,
        refreshToken
      });
    } catch (error) {
      next(error);
    }
  },
  
  async login(req, res, next) {
    try {
      const { email, password } = req.body;
      
      // Find user
      const user = await User.findOne({ email });
      if (!user) {
        return res.status(401).json({ message: 'Invalid credentials' });
      }
      
      // Check if user is active
      if (!user.isActive) {
        return res.status(403).json({ message: 'Account is inactive' });
      }
      
      // Verify password
      const isPasswordValid = await bcrypt.compare(password, user.password);
      if (!isPasswordValid) {
        return res.status(401).json({ message: 'Invalid credentials' });
      }
      
      // Generate tokens
      const { accessToken, refreshToken } = generateTokens(user);
      
      // Save device token if provided
      if (req.body.deviceToken) {
        if (!user.deviceTokens.includes(req.body.deviceToken)) {
          user.deviceTokens.push(req.body.deviceToken);
          await user.save();
        }
      }
      
      res.json({
        user: {
          id: user._id,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          accountType: user.accountType
        },
        accessToken,
        refreshToken
      });
    } catch (error) {
      next(error);
    }
  },
  
  async refreshToken(req, res, next) {
    try {
      const { refreshToken } = req.body;
      
      if (!refreshToken) {
        return res.status(400).json({ message: 'Refresh token is required' });
      }
      
      // Verify refresh token
      const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
      
      // Get user
      const user = await User.findById(decoded.userId);
      if (!user || !user.isActive) {
        return res.status(401).json({ message: 'Invalid token' });
      }
      
      // Generate new tokens
      const tokens = generateTokens(user);
      
      res.json(tokens);
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        return res.status(401).json({ message: 'Refresh token expired' });
      }
      next(error);
    }
  },
  
  async forgotPassword(req, res, next) {
    try {
      const { email } = req.body;
      
      // Find user
      const user = await User.findOne({ email });
      if (!user) {
        // Return success anyway for security
        return res.json({ message: 'Password reset email sent if account exists' });
      }
      
      // Generate reset token
      const resetToken = crypto.randomBytes(32).toString('hex');
      const hashedToken = await bcrypt.hash(resetToken, 10);
      
      // Save token to user
      user.passwordResetToken = hashedToken;
      user.passwordResetExpires = Date.now() + 3600000; // 1 hour
      await user.save();
      
      // Send email with reset link (Implementation depends on email service)
      // sendResetEmail(user.email, resetToken);
      
      res.json({ message: 'Password reset email sent if account exists' });
    } catch (error) {
      next(error);
    }
  },
  
  async resetPassword(req, res, next) {
    try {
      const { token, password } = req.body;
      
      // Find user with non-expired token
      const user = await User.findOne({
        passwordResetExpires: { $gt: Date.now() }
      });
      
      if (!user) {
        return res.status(400).json({ message: 'Token is invalid or has expired' });
      }
      
      // Verify token
      const isValidToken = await bcrypt.compare(token, user.passwordResetToken);
      if (!isValidToken) {
        return res.status(400).json({ message: 'Token is invalid or has expired' });
      }
      
      // Update password
      const hashedPassword = await bcrypt.hash(password, 10);
      user.password = hashedPassword;
      user.passwordResetToken = undefined;
      user.passwordResetExpires = undefined;
      await user.save();
      
      res.json({ message: 'Password has been reset successfully' });
    } catch (error) {
      next(error);
    }
  },
  
  async logout(req, res, next) {
    try {
      const { deviceToken } = req.body;
      const userId = req.user.id;
      
      // Remove device token if provided
      if (deviceToken) {
        await User.updateOne(
          { _id: userId },
          { $pull: { deviceTokens: deviceToken } }
        );
      }
      
      res.json({ message: 'Logged out successfully' });
    } catch (error) {
      next(error);
    }
  },
  
  // User profile methods
  async getCurrentUser(req, res, next) {
    try {
      const userId = req.user.id;
      
      const user = await User.findById(userId).select('-password');
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }
      
      res.json(user);
    } catch (error) {
      next(error);
    }
  },
  
  async updateCurrentUser(req, res, next) {
    try {
      const userId = req.user.id;
      const { firstName, lastName, phoneNumber } = req.body;
      
      // Update user
      const updatedUser = await User.findByIdAndUpdate(
        userId,
        { firstName, lastName, phoneNumber },
        { new: true }
      ).select('-password');
      
      res.json(updatedUser);
    } catch (error) {
      next(error);
    }
  },
  
  async updatePassword(req, res, next) {
    try {
      const userId = req.user.id;
      const { currentPassword, newPassword } = req.body;
      
      // Find user
      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }
      
      // Verify current password
      const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
      if (!isPasswordValid) {
        return res.status(400).json({ message: 'Current password is incorrect' });
      }
      
      // Update password
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      user.password = hashedPassword;
      await user.save();
      
      res.json({ message: 'Password updated successfully' });
    } catch (error) {
      next(error);
    }
  },
  
  async updateProfilePicture(req, res, next) {
    try {
      const userId = req.user.id;
      
      if (!req.file) {
        return res.status(400).json({ message: 'No file uploaded' });
      }
      
      // Upload to cloud storage and get URL
      // const fileUrl = await uploadToStorage(req.file);
      const fileUrl = req.file.path; // Temporary local path for example
      
      // Update user
      const updatedUser = await User.findByIdAndUpdate(
        userId,
        { profilePicture: fileUrl },
        { new: true }
      ).select('-password');
      
      res.json(updatedUser);
    } catch (error) {
      next(error);
    }
  },
  
  async getUserById(req, res, next) {
    try {
      const { userId } = req.params;
      
      // Get basic public user info
      const user = await User.findById(userId).select('firstName lastName profilePicture accountType');
      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }
      
      res.json(user);
    } catch (error) {
      next(error);
    }
  }}
// Provider Controller
const providerController = {
  async createProviderProfile(req, res, next) {
    try {
      const userId = req.user.id;
      const { 
        businessName, 
        description, 
        categories, 
        skills 
      } = req.body;
      
      // Check if profile already exists
      const existingProfile = await ServiceProvider.findOne({ userId });
      if (existingProfile) {
        return res.status(400).json({ message: 'Provider profile already exists' });
      }
      
      // Create profile
      const providerProfile = new ServiceProvider({
        userId,
        businessName,
        description,
        categories,
        skills
      });
      
      await providerProfile.save();
      
      res.status(201).json(providerProfile);
    } catch (error) {
      next(error);
    }
  },
  
  async updateProviderProfile(req, res, next) {
    try {
      const userId = req.user.id;
      const { 
        businessName, 
        description, 
        categories, 
        skills,
        certificates
      } = req.body;
      
      // Update profile
      const updatedProfile = await ServiceProvider.findOneAndUpdate(
        { userId },
        { 
          businessName, 
          description, 
          categories, 
          skills,
          certificates
        },
        { new: true }
      );
      
      if (!updatedProfile) {
        return res.status(404).json({ message: 'Provider profile not found' });
      }
      
      res.json(updatedProfile);
    } catch (error) {
      next(error);
    }
  },
  
  async getProviderProfile(req, res, next) {
    try {
      const userId = req.user.id;
      
      // Get profile with populated categories
      const profile = await ServiceProvider.findOne({ userId })
        .populate('categories', 'name description icon');
      
      if (!profile) {
        return res.status(404).json({ message: 'Provider profile not found' });
      }
      
      res.json(profile);
    } catch (error) {
      next(error);
    }
  },
  
  async updateAvailability(req, res, next) {
    try {
      const userId = req.user.id;
      const { availability } = req.body;
      
      // Update availability
      const updatedProfile = await ServiceProvider.findOneAndUpdate(
        { userId },
        { availability },
        { new: true }
      );
      
      if (!updatedProfile) {
        return res.status(404).json({ message: 'Provider profile not found' });
      }
      
      res.json(updatedProfile);
    } catch (error) {
      next(error);
    }
  },
  
  async updateBankDetails(req, res, next) {
    try {
      const userId = req.user.id;
      const { bankDetails } = req.body;
      
      // Update bank details
      const updatedProfile = await ServiceProvider.findOneAndUpdate(
        { userId },
        { bankDetails },
        { new: true }
      );
      
      if (!updatedProfile) {
        return res.status(404).json({ message: 'Provider profile not found' });
      }
      
      // Return limited response for security
      res.json({
        message: 'Bank details updated successfully',
        bankDetails: {
          accountHolder: bankDetails.accountHolder,
          bankName: bankDetails.bankName,
          accountNumberLast4: bankDetails.accountNumber.slice(-4)
        }
      });
    } catch (error) {
      next(error);
    }
  }
};

// Category Controller
const categoryController = {
  async getAllCategories(req, res, next) {
    try {
      const categories = await Category.find({ isActive: true })
        .select('name description icon parent');
      
      res.json(categories);
    } catch (error) {
      next(error);
    }
  },
  
  async getCategoryById(req, res, next) {
    try {
      const { categoryId } = req.params;
      
      const category = await Category.findById(categoryId);
      if (!category) {
        return res.status(404).json({ message: 'Category not found' });
      }
      
      res.json(category);
    } catch (error) {
      next(error);
    }
  },
  
  async createCategory(req, res, next) {
    try {
      const { name, description, parent, icon, basePrice, priceFactors } = req.body;
      
      const category = new Category({
        name,
        description,
        parent,
        icon,
        basePrice,
        priceFactors
      });
      
      await category.save();
      
      res.status(201).json(category);
    } catch (error) {
      next(error);
    }
  },
  
  async updateCategory(req, res, next) {
    try {
      const { categoryId } = req.params;
      const { name, description, parent, icon, isActive, basePrice, priceFactors } = req.body;
      
      const updatedCategory = await Category.findByIdAndUpdate(
        categoryId,
        { name, description, parent, icon, isActive, basePrice, priceFactors },
        { new: true }
      );
      
      if (!updatedCategory) {
        return res.status(404).json({ message: 'Category not found' });
      }
      
      res.json(updatedCategory);
    } catch (error) {
      next(error);
    }
  },
  
  async deleteCategory(req, res, next) {
    try {
      const { categoryId } = req.params;
      
      // Check if category has tasks
      const hasActiveTasks = await Task.exists({ category: categoryId, status: { $ne: 'completed' } });
      if (hasActiveTasks) {
        return res.status(400).json({ message: 'Cannot delete category with active tasks' });
      }
      
      // Soft delete by setting isActive to false
      const deletedCategory = await Category.findByIdAndUpdate(
        categoryId,
        { isActive: false },
        { new: true }
      );
      
      if (!deletedCategory) {
        return res.status(404).json({ message: 'Category not found' });
      }
      
      res.json({ message: 'Category deleted successfully' });
    } catch (error) {
      next(error);
    }
  },
  
  async getProvidersByCategory(req, res, next) {
    try {
      const { categoryId } = req.params;
      const { page = 1, limit = 10, location } = req.query;
      
      const query = { categories: categoryId };
      
      // Add location filtering if provided
      if (location) {
        const [longitude, latitude] = location.split(',').map(Number);
        const maxDistance = req.query.distance || 10000; // default 10km
        
        query.location = {
          $near: {
            $geometry: {
              type: 'Point',
              coordinates: [longitude, latitude]
            },
            $maxDistance: maxDistance
          }
        };
      }
      
      // Find providers with pagination
      const providers = await ServiceProvider.find(query)
        .skip((page - 1) * limit)
        .limit(Number(limit))
        .populate('userId', 'firstName lastName profilePicture')
        .select('-bankDetails');
      
      const total = await ServiceProvider.countDocuments(query);
      
      res.json({
        providers,
        totalPages: Math.ceil(total / limit),
        currentPage: page
      });
    } catch (error) {
      next(error);
    }
  }
};

// Task Controller
const taskController = {
  async createTask(req, res, next) {
    try {
      const { 
        category, 
        title, 
        description, 
        location, 
        budget, 
        scheduledDate,
        attachments 
      } = req.body;
      
      // Create task
      const task = new Task({
        customer: req.user.id,
        category,
        title,
        description,
        location,
        budget,
        scheduledDate,
        attachments
      });
      
      // If AI categorization is enabled
      if (req.body.useAI) {
        const aiTags = await categorizeTasks(description);
        task.aiCategorizationTags = aiTags;
        
        // Suggest price based on category and description
        task.aiPriceSuggestion = await suggestPrice(category, description);
      }
      
      await task.save();
      
      res.status(201).json(task);
    } catch (error) {
      next(error);
    }
  },
  
  async getCustomerTasks(req, res, next) {
    try {
      const { status, page = 1, limit = 10 } = req.query;
      
      const query = { customer: req.user.id };
      
      // Add status filter if provided
      if (status) {
        query.status = status;
      }
      
      // Get tasks with pagination
      const tasks = await Task.find(query)
        .skip((page - 1) * limit)
        .limit(Number(limit))
        .populate('category', 'name')
        .populate('provider', 'firstName lastName profilePicture')
        .sort({ createdAt: -1 });
      
      const total = await Task.countDocuments(query);
      
      res.json({
        tasks,
        totalPages: Math.ceil(total / limit),
        currentPage: page
      });
    } catch (error) {
      next(error);
    }
  },
  
  async getTaskById(req, res, next) {
    try {
      const { taskId } = req.params;
      
      const task = await Task.findById(taskId)
        .populate('category', 'name description')
        .populate('customer', 'firstName lastName profilePicture')
        .populate('provider', 'firstName lastName profilePicture');
      
      if (!task) {
        return res.status(404).json({ message: 'Task not found' });
      }
      
      // Check if user has permission to view the task
      if (!req.user.isAdmin && 
          task.customer.toString() !== req.user.id && 
          (task.provider && task.provider._id.toString() !== req.user.id)) {
        return res.status(403).json({ message: 'Not authorized to view this task' });
      }
      
      res.json(task);
    } catch (error) {
      next(error);
    }
  },
  
  async updateTask(req, res, next) {
    try {
      const { taskId } = req.params;
      const { 
        title, 
        description, 
        location, 
        budget, 
        scheduledDate 
      } = req.body;
      
      // Find task
      const task = await Task.findById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Task not found' });
      }
      
      // Check if user owns the task
      if (task.customer.toString() !== req.user.id) {
        return res.status(403).json({ message: 'Not authorized to update this task' });
      }
      
      // Check if task can be updated
      if (['in_progress', 'completed', 'cancelled'].includes(task.status)) {
        return res.status(400).json({ message: `Cannot update task in ${task.status} status` });
      }
      
      // Update task
      task.title = title || task.title;
      task.description = description || task.description;
      task.location = location || task.location;
      task.budget = budget || task.budget;
      task.scheduledDate = scheduledDate || task.scheduledDate;
      
      await task.save();
      
      res.json(task);
    } catch (error) {
      next(error);
    }
  },
  
  async deleteTask(req, res, next) {
    try {
      const { taskId } = req.params;
      
      // Find task
      const task = await Task.findById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Task not found' });
      }
      
      // Check if user owns the task
      if (task.customer.toString() !== req.user.id) {
        return res.status(403).json({ message: 'Not authorized to delete this task' });
      }
      
      // Check if task can be deleted
      if (['in_progress', 'completed'].includes(task.status)) {
        return res.status(400).json({ message: `Cannot delete task in ${task.status} status` });
      }
      
      await task.remove();
      
      res.json({ message: 'Task deleted successfully' });
    } catch (error) {
      next(error);
    }
  },
  
  async cancelTask(req, res, next) {
    try {
      const { taskId } = req.params;
      const { reason } = req.body;
      
      // Find task
      const task = await Task.findById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Task not found' });
      }
      
      // Check if user owns the task
      if (task.customer.toString() !== req.user.id) {
        return res.status(403).json({ message: 'Not authorized to cancel this task' });
      }
      
      // Check if task can be cancelled
      if (['completed', 'cancelled'].includes(task.status)) {
        return res.status(400).json({ message: `Cannot cancel task in ${task.status} status` });
      }
      
      // Cancel task
      task.status = 'cancelled';
      task.cancellationReason = reason;
      
      await task.save();
      
      // Notify provider if assigned
      if (task.provider) {
        // sendProviderNotification(task.provider, 'Task Cancelled', `Task "${task.title}" has been cancelled`);
      }
      
      res.json({ message: 'Task cancelled successfully', task });
    } catch (error) {
      next(error);
    }
  },
  
  async getProviderTasks(req, res, next) {
    try {
      const { status, page = 1, limit = 10 } = req.query;
      
      const query = { provider: req.user.id };
      
      // Add status filter if provided
      if (status) {
        query.status = status;
      }
      
      // Get tasks with pagination
      const tasks = await Task.find(query)
        .skip((page - 1) * limit)
        .limit(Number(limit))
        .populate('category', 'name')
        .populate('customer', 'firstName lastName profilePicture')
        .sort({ createdAt: -1 });
      
      const total = await Task.countDocuments(query);
      
      res.json({
        tasks,
        totalPages: Math.ceil(total / limit),
        currentPage: page
      });
    } catch (error) {
      next(error);
    }
  },
  
  async applyForTask(req, res, next) {
    try {
      const { taskId } = req.params;
      const { proposal, price } = req.body;
      
      // Find task
      const task = await Task.findById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Task not found' });
      }
      
      // Check if task is open
      if (task.status !== 'posted') {
        return res.status(400).json({ message: 'Task is not available for applications' });
      }
      
      // Check if already applied
      const existingApplication = await TaskApplication.findOne({
        task: taskId,
        provider: req.user.id
      });
      
      if (existingApplication) {
        return res.status(400).json({ message: 'Already applied to this task' });
      }
      
      // Create application
      const application = new TaskApplication({
        task: taskId,
        provider: req.user.id,
        proposal,
        price
      });
      
      await application.save();
      
      // Notify customer
      // sendCustomerNotification(task.customer, 'New Application', `You have a new application for task "${task.title}"`);
      
      res.status(201).json(application);
    } catch (error) {
      next(error);
    }
  },
  
  async assignTaskToProvider(req, res, next) {
    try {
      const { taskId, providerId } = req.params;
      
      // Find task
      const task = await Task.findById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Task not found' });
      }
      
      // Check if user owns the task
      if (task.customer.toString() !== req.user.id) {
        return res.status(403).json({ message: 'Not authorized to assign this task' });
      }
      
      // Check if task is in posted status
      if (task.status !== 'posted') {
        return res.status(400).json({ message: 'Task cannot be assigned in current status' });
      }
      
      // Verify provider exists
      const provider = await User.findById(providerId);
      if (!provider || provider.accountType !== 'provider') {
        return res.status(404).json({ message: 'Provider not found' });
      }
      
      // Update task
      task.provider = providerId;
      task.status = 'assigned';
      
      await task.save();
      
      // Notify provider
      // sendProviderNotification(providerId, 'Task Assigned', `You have been assigned to task "${task.title}"`);
      
      res.json(task);
    } catch (error) {
      next(error);
    }
  },
  
  async startTask(req, res, next) {
    try {
      const { taskId } = req.params;
      
      // Find task
      const task = await Task.findById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Task not found' });
      }
      
      // Check if user is the assigned provider
      if (task.provider.toString() !== req.user.id) {
        return res.status(403).json({ message: 'Not authorized to start this task' });
      }
      
      // Check if task is in assigned status
      if (task.status !== 'assigned') {
        return res.status(400).json({ message: 'Task cannot be started in current status' });
      }
      
      // Update task
      task.status = 'in_progress';
      task.startDate = new Date();
      
      await task.save();
      
      // Notify customer
      // sendCustomerNotification(task.customer, 'Task Started', `Provider has started working on task "${task.title}"`);
      
      res.json(task);
    } catch (error) {
      next(error);
    }
  },
  
  async completeTask(req, res, next) {
    try {
      const { taskId } = req.params;
      const { notes, attachments } = req.body;
      
      // Find task
      const task = await Task.findById(taskId);
      
      if (!task) {
        return res.status(404).json({ message: 'Task not found' });
      }
      
      // Check if user is the assigned provider
      if (task.provider.toString() !== req.user.id) {
        return res.status(403).json({ message: 'Not authorized to complete this task' });
      }
      
      // Check if task is in progress
      if (task.status !== 'in_progress') {
        return res.status(400).json({ message: 'Task cannot be completed in current status' });
      }
      
      // Update task
      task.status = 'completed';
      task.completionDate = new Date();
      task.completionNotes = notes;
      
      // Add completion attachments
      if (attachments && attachments.length) {
        task.completionAttachments = attachments;
      }
      
      await task.save();
      
      // Notify customer
      // sendCustomerNotification(task.customer, 'Task Completed', `Provider has completed task "${task.title}"`);
      
      res.json(task);
    } catch (error) {
      next(error);
    }
  },
  
  // Task search and discovery controllers

  async searchTasks(req, res, next) {
    try {
      const { query, category, location, minPrice, maxPrice, sort, status } = req.query;
      
      // Build search query
      const searchQuery = {};
      
      if (query) {
        searchQuery.$or = [
          { title: { $regex: query, $options: 'i' } },
          { description: { $regex: query, $options: 'i' } }
        ];
      }
      
      if (category) {
        searchQuery.category = category;
      }
      
      if (status) {
        searchQuery.status = status;
      }
      
      // Location-based search
      if (location) {
        const { lat, lng, radius = 10 } = JSON.parse(location);
        searchQuery.location = {
          $near: {
            $geometry: {
              type: "Point",
              coordinates: [lng, lat]
            },
            $maxDistance: radius * 1000 // Convert km to meters
          }
        };
      }
      
      // Price range
      if (minPrice || maxPrice) {
        searchQuery.price = {};
        if (minPrice) searchQuery.price.$gte = parseFloat(minPrice);
        if (maxPrice) searchQuery.price.$lte = parseFloat(maxPrice);
      }
      
      // Sort options
      const sortOptions = {};
      if (sort) {
        const [field, order] = sort.split(':');
        sortOptions[field] = order === 'desc' ? -1 : 1;
      } else {
        // Default sort by creation date (newest first)
        sortOptions.createdAt = -1;
      }
      
      // Pagination
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const skip = (page - 1) * limit;
      
      const tasks = await Task.find(searchQuery)
        .sort(sortOptions)
        .skip(skip)
        .limit(limit)
        .populate('category', 'name icon')
        .populate('customer', 'name profilePicture rating');
      
      const totalTasks = await Task.countDocuments(searchQuery);
      
      res.status(200).json({
        success: true,
        count: tasks.length,
        totalPages: Math.ceil(totalTasks / limit),
        currentPage: page,
        tasks
      });
    } catch (error) {
      next(error);
    }
  },

  async getNearbyTasks(req, res, next) {
    try {
      const { lat, lng, radius = 10 } = req.query;
      
      if (!lat || !lng) {
        return res.status(400).json({
          success: false,
          message: 'Latitude and longitude are required'
        });
      }
      
      const tasks = await Task.find({
        location: {
          $near: {
            $geometry: {
              type: "Point",
              coordinates: [parseFloat(lng), parseFloat(lat)]
            },
            $maxDistance: parseFloat(radius) * 1000 // Convert km to meters
          }
        },
        status: { $in: ['open', 'pending'] } // Only show available tasks
      })
      .limit(20)
      .populate('category', 'name icon')
      .populate('customer', 'name profilePicture rating');
      
      res.status(200).json({
        success: true,
        count: tasks.length,
        tasks
      });
    } catch (error) {
      next(error);
    }
  }
}
// Review Controller
const reviewController = {
  async createReview(req, res, next) {
    try {
      const { taskId } = req.params;
      const { rating, comment } = req.body;
      const userId = req.user.id;

      // Find the task
      const task = await Task.findById(taskId);
      
      if (!task) {
        return res.status(404).json({
          success: false,
          message: 'Task not found'
        });
      }
      
      // Check if the task is completed
      if (task.status !== 'completed') {
        return res.status(400).json({
          success: false,
          message: 'Reviews can only be created for completed tasks'
        });
      }
      
      // Check if the user is the customer or provider of the task
      if (task.customer.toString() !== userId && task.provider.toString() !== userId) {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to review this task'
        });
      }
      
      // Determine who is being reviewed
      const reviewedUser = task.customer.toString() === userId
        ? task.provider
        : task.customer;
      
      // Check if the user already reviewed this task
      const existingReview = await Review.findOne({
        task: taskId,
        reviewer: userId
      });
      
      if (existingReview) {
        return res.status(400).json({
          success: false,
          message: 'You have already reviewed this task'
        });
      }
      
      // Create the review
      const review = await Review.create({
        task: taskId,
        reviewer: userId,
        reviewedUser,
        rating,
        comment
      });
      
      // Update user's average rating
      await updateUserRating(reviewedUser);
      
      res.status(201).json({
        success: true,
        review
      });
    } catch (error) {
      next(error);
    }
  },

  async getTaskReviews(req, res, next) {
    try {
      const { taskId } = req.params;
      
      const reviews = await Review.find({ task: taskId })
        .populate('reviewer', 'name profilePicture')
        .populate('reviewedUser', 'name profilePicture');
      
      res.status(200).json({
        success: true,
        count: reviews.length,
        reviews
      });
    } catch (error) {
      next(error);
    }
  },

  async getUserReviews(req, res, next) {
    try {
      const { userId } = req.params;
      
      const reviews = await Review.find({ reviewedUser: userId })
        .populate('reviewer', 'name profilePicture')
        .populate('task', 'title');
      
      // Calculate average rating
      const totalReviews = reviews.length;
      const averageRating = totalReviews > 0
        ? reviews.reduce((sum, review) => sum + review.rating, 0) / totalReviews
        : 0;
      
      res.status(200).json({
        success: true,
        count: totalReviews,
        averageRating,
        reviews
      });
    } catch (error) {
      next(error);
    }
  },

  async updateReview(req, res, next) {
    try {
      const { reviewId } = req.params;
      const { rating, comment } = req.body;
      const userId = req.user.id;
      
      // Find the review
      const review = await Review.findById(reviewId);
      
      if (!review) {
        return res.status(404).json({
          success: false,
          message: 'Review not found'
        });
      }
      
      // Check if the user is the reviewer
      if (review.reviewer.toString() !== userId) {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to update this review'
        });
      }
      
      // Update the review
      review.rating = rating || review.rating;
      review.comment = comment || review.comment;
      review.updatedAt = Date.now();
      
      await review.save();
      
      // Update user's average rating
      await updateUserRating(review.reviewedUser);
      
      res.status(200).json({
        success: true,
        review
      });
    } catch (error) {
      next(error);
    }
  },

  async deleteReview(req, res, next) {
    try {
      const { reviewId } = req.params;
      const userId = req.user.id;
      
      // Find the review
      const review = await Review.findById(reviewId);
      
      if (!review) {
        return res.status(404).json({
          success: false,
          message: 'Review not found'
        });
      }
      
      // Check if the user is the reviewer or has admin rights
      if (review.reviewer.toString() !== userId && req.user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to delete this review'
        });
      }
      
      const reviewedUserId = review.reviewedUser;
      
      // Delete the review
      await Review.findByIdAndDelete(reviewId);
      
      // Update user's average rating
      await updateUserRating(reviewedUserId);
      
      res.status(200).json({
        success: true,
        message: 'Review deleted successfully'
      });
    } catch (error) {
      next(error);
    }
  }
}

// Helper function to update user rating
const updateUserRating = async (userId) => {
  const reviews = await Review.find({ reviewedUser: userId });
  
  const totalReviews = reviews.length;
  const averageRating = totalReviews > 0
    ? reviews.reduce((sum, review) => sum + review.rating, 0) / totalReviews
    : 0;
  
  await User.findByIdAndUpdate(userId, {
    rating: averageRating,
    reviewCount: totalReviews
  });
}
// Conversation Controller
const conversationController = {
  async getUserConversations(req, res, next) {
    try {
      const userId = req.user.id;
      
      // Find all conversations where the user is a participant
      const conversations = await Conversation.find({
        participants: userId
      })
      .populate({
        path: 'participants',
        select: 'name profilePicture'
      })
      .populate({
        path: 'lastMessage',
        select: 'content createdAt sender type'
      })
      .sort({ updatedAt: -1 });
      
      // Calculate unread messages count for each conversation
      const conversationsWithUnreadCount = await Promise.all(
        conversations.map(async (conversation) => {
          const unreadCount = await Message.countDocuments({
            conversation: conversation._id,
            sender: { $ne: userId },
            readBy: { $ne: userId }
          });
          
          // Get the other participant (for direct conversations)
          const otherParticipant = conversation.participants.find(
            p => p._id.toString() !== userId
          );
          
          return {
            ...conversation.toObject(),
            unreadCount,
            otherParticipant
          };
        })
      );
      
      res.status(200).json({
        success: true,
        count: conversations.length,
        conversations: conversationsWithUnreadCount
      });
    } catch (error) {
      next(error);
    }
  },

  async getConversationById(req, res, next) {
    try {
      const { conversationId } = req.params;
      const userId = req.user.id;
      
      // Find the conversation
      const conversation = await Conversation.findById(conversationId)
        .populate({
          path: 'participants',
          select: 'name profilePicture'
        })
        .populate({
          path: 'task',
          select: 'title status'
        });
      
      if (!conversation) {
        return res.status(404).json({
          success: false,
          message: 'Conversation not found'
        });
      }
      
      // Check if the user is a participant
      if (!conversation.participants.some(p => p._id.toString() === userId)) {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to view this conversation'
        });
      }
      
      // Update seen status for all messages in this conversation
      await Message.updateMany(
        {
          conversation: conversationId,
          sender: { $ne: userId },
          readBy: { $ne: userId }
        },
        {
          $addToSet: { readBy: userId }
        }
      );
      
      res.status(200).json({
        success: true,
        conversation
      });
    } catch (error) {
      next(error);
    }
  },

  async createConversation(req, res, next) {
    try {
      const { participantId, taskId, initialMessage } = req.body;
      const userId = req.user.id;
      
      // Validate participant
      const participant = await User.findById(participantId);
      if (!participant) {
        return res.status(404).json({
          success: false,
          message: 'Participant not found'
        });
      }
      
      // Check if a conversation already exists between these users
      let conversation = await Conversation.findOne({
        participants: { $all: [userId, participantId] },
        ...(taskId ? { task: taskId } : {})
      });
      
      // If task is provided, validate it
      let task;
      if (taskId) {
        task = await Task.findById(taskId);
        if (!task) {
          return res.status(404).json({
            success: false,
            message: 'Task not found'
          });
        }
        
        // Check if the user is the customer or a provider who applied
        const isCustomer = task.customer.toString() === userId;
        const isProvider = task.provider?.toString() === userId || 
                          (task.applicants && task.applicants.includes(userId));
        
        if (!isCustomer && !isProvider) {
          return res.status(403).json({
            success: false,
            message: 'You are not authorized to start a conversation for this task'
          });
        }
      }
      
      // Create a new conversation if one doesn't exist
      if (!conversation) {
        conversation = await Conversation.create({
          participants: [userId, participantId],
          task: taskId,
          createdBy: userId
        });
      }
      
      // Add initial message if provided
      if (initialMessage) {
        const message = await Message.create({
          conversation: conversation._id,
          sender: userId,
          content: initialMessage,
          type: 'text'
        });
        
        // Update conversation's last message
        conversation.lastMessage = message._id;
        await conversation.save();
      }
      
      // Fetch and return the complete conversation
      const completeConversation = await Conversation.findById(conversation._id)
        .populate({
          path: 'participants',
          select: 'name profilePicture'
        })
        .populate({
          path: 'task',
          select: 'title status'
        });
      
      res.status(201).json({
        success: true,
        conversation: completeConversation
      });
    } catch (error) {
      next(error);
    }
  },
// Message Controller

  async getConversationMessages(req, res, next) {
    try {
      const { conversationId } = req.params;
      const userId = req.user.id;
      
      // Verify conversation exists and user is participant
      const conversation = await Conversation.findById(conversationId);
      
      if (!conversation) {
        return res.status(404).json({
          success: false,
          message: 'Conversation not found'
        });
      }
      
      if (!conversation.participants.includes(userId)) {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to view messages in this conversation'
        });
      }
      
      // Pagination
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 20;
      const skip = (page - 1) * limit;
      
      // Get messages with pagination (most recent first, then reverse for client)
      const messages = await Message.find({ conversation: conversationId })
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .populate({
          path: 'sender',
          select: 'name profilePicture'
        });
      
      // Count total messages in conversation
      const totalMessages = await Message.countDocuments({ conversation: conversationId });
      
      // Mark messages as read
      await Message.updateMany(
        {
          conversation: conversationId,
          sender: { $ne: userId },
          readBy: { $ne: userId }
        },
        {
          $addToSet: { readBy: userId }
        }
      );
      
      res.status(200).json({
        success: true,
        count: messages.length,
        totalPages: Math.ceil(totalMessages / limit),
        currentPage: page,
        messages: messages.reverse() // Reverse to show oldest first
      });
    } catch (error) {
      next(error);
    }
  },

  async sendMessage(req, res, next) {
    try {
      const { conversationId } = req.params;
      const { content, type = 'text' } = req.body;
      const userId = req.user.id;
      
      // Verify conversation exists and user is participant
      const conversation = await Conversation.findById(conversationId);
      
      if (!conversation) {
        return res.status(404).json({
          success: false,
          message: 'Conversation not found'
        });
      }
      
      if (!conversation.participants.includes(userId)) {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to send messages in this conversation'
        });
      }
      
      // Create new message
      const message = await Message.create({
        conversation: conversationId,
        sender: userId,
        content,
        type,
        readBy: [userId] // Sender has read the message
      });
      
      // Populate sender information
      await message.populate({
        path: 'sender',
        select: 'name profilePicture'
      });
      
      // Update conversation's last message and timestamp
      conversation.lastMessage = message._id;
      conversation.updatedAt = Date.now();
      await conversation.save();
      
      // TODO: Send real-time notification to other participants
      
      res.status(201).json({
        success: true,
        message
      });
    } catch (error) {
      next(error);
    }
  },

  async sendAttachment(req, res, next) {
    try {
      const { conversationId } = req.params;
      const userId = req.user.id;
      const file = req.file;
      
      if (!file) {
        return res.status(400).json({
          success: false,
          message: 'No file uploaded'
        });
      }
      
      // Verify conversation exists and user is participant
      const conversation = await Conversation.findById(conversationId);
      
      if (!conversation) {
        return res.status(404).json({
          success: false,
          message: 'Conversation not found'
        });
      }
      
      if (!conversation.participants.includes(userId)) {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to send messages in this conversation'
        });
      }
      
      // Determine file type
      let fileType = 'file';
      if (file.mimetype.startsWith('image/')) {
        fileType = 'image';
      } else if (file.mimetype.startsWith('video/')) {
        fileType = 'video';
      } else if (file.mimetype.startsWith('audio/')) {
        fileType = 'audio';
      }
      
      // Create new message with attachment
      const message = await Message.create({
        conversation: conversationId,
        sender: userId,
        content: file.path,
        type: fileType,
        filename: file.originalname,
        filesize: file.size,
        mimetype: file.mimetype,
        readBy: [userId] // Sender has read the message
      });
      
      // Populate sender information
      await message.populate({
        path: 'sender',
        select: 'name profilePicture'
      });
      
      // Update conversation's last message and timestamp
      conversation.lastMessage = message._id;
      conversation.updatedAt = Date.now();
      await conversation.save();
      
      // TODO: Send real-time notification to other participants
      
      res.status(201).json({
        success: true,
        message
      });
    } catch (error) {
      next(error);
    }
  },

  async markMessagesAsRead(req, res, next) {
    try {
      const { conversationId } = req.params;
      const userId = req.user.id;
      
      // Verify conversation exists and user is participant
      const conversation = await Conversation.findById(conversationId);
      
      if (!conversation) {
        return res.status(404).json({
          success: false,
          message: 'Conversation not found'
        });
      }
      
      if (!conversation.participants.includes(userId)) {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to access this conversation'
        });
      }
      
      // Mark all unread messages as read
      const updateResult = await Message.updateMany(
        {
          conversation: conversationId,
          sender: { $ne: userId },
          readBy: { $ne: userId }
        },
        {
          $addToSet: { readBy: userId }
        }
      );
      
      res.status(200).json({
        success: true,
        message: 'Messages marked as read',
        count: updateResult.modifiedCount
      });
    } catch (error) {
      next(error);
    }
  }} 
  const paymentController = {
    async createTaskPayment(req, res, next) {
      try {
        const { taskId } = req.params;
        const { amount, paymentMethod } = req.body;
        const userId = req.user.id;
  
        // Find the task
        const task = await Task.findById(taskId);
  
        if (!task) {
          return res.status(404).json({
            success: false,
            message: 'Task not found'
          });
        }
  
        // Check if the user is the task owner
        if (task.customer.toString() !== userId) {
          return res.status(403).json({
            success: false,
            message: 'You are not authorized to pay for this task'
          });
        }
  
        // Process payment (this is a placeholder for actual payment processing logic)
        const payment = await Payment.create({
          task: taskId,
          customer: userId,
          amount,
          paymentMethod,
          status: 'completed'
        });
  
        // Update task status
        task.status = 'paid';
        await task.save();
  
        res.status(201).json({
          success: true,
          payment
        });
      } catch (error) {
        next(error);
      }
    },
  
    async getUserPayments(req, res, next) {
      try {
        const userId = req.user.id;
  
        const payments = await Payment.find({ customer: userId });
  
        res.status(200).json({
          success: true,
          payments
        });
      } catch (error) {
        next(error);
      }
    },
  
    async getPaymentById(req, res, next) {
      try {
        const { paymentId } = req.params;
        const userId = req.user.id;
  
        const payment = await Payment.findById(paymentId);
  
        if (!payment) {
          return res.status(404).json({
            success: false,
            message: 'Payment not found'
          });
        }
  
        // Check if the user is the payment owner or has admin rights
        if (payment.customer.toString() !== userId && req.user.role !== 'admin') {
          return res.status(403).json({
            success: false,
            message: 'You are not authorized to view this payment'
          });
        }
  
        res.status(200).json({
          success: true,
          payment
        });
      } catch (error) {
        next(error);
      }
    },
  
    async refundPayment(req, res, next) {
      try {
        const { paymentId } = req.params;
  
        const payment = await Payment.findById(paymentId);
  
        if (!payment) {
          return res.status(404).json({
            success: false,
            message: 'Payment not found'
          });
        }
  
        // Process refund (this is a placeholder for actual refund processing logic)
        payment.status = 'refunded';
        await payment.save();
  
        res.status(200).json({
          success: true,
          payment
        });
      } catch (error) {
        next(error);
      }
    },
  
    async getProviderPayouts(req, res, next) {
      try {
        const userId = req.user.id;
  
        const payouts = await Payout.find({ provider: userId });
  
        res.status(200).json({
          success: true,
          payouts
        });
      } catch (error) {
        next(error);
      }
    },
  
    async requestPayout(req, res, next) {
      try {
        const userId = req.user.id;
        const { amount } = req.body;
  
        // Check if the provider has enough balance
        const provider = await Provider.findOne({ user: userId });
  
        if (provider.balance < amount) {
          return res.status(400).json({
            success: false,
            message: 'Insufficient balance'
          });
        }
  
        // Create payout request
        const payout = await Payout.create({
          provider: userId,
          amount,
          status: 'pending'
        });
  
        // Deduct from provider's balance
        provider.balance -= amount;
        await provider.save();
  
        res.status(201).json({
          success: true,
          payout
        });
      } catch (error) {
        next(error);
      }
    }
  }
  
  const adminController = {
    async getAllUsers(req, res, next) {
      try {
        const users = await User.find();
  
        res.status(200).json({
          success: true,
          users
        });
      } catch (error) {
        next(error);
      }
    },
  
    async updateUserStatus(req, res, next) {
      try {
        const { userId } = req.params;
        const { status } = req.body;
  
        const user = await User.findByIdAndUpdate(userId, { status }, { new: true });
  
        if (!user) {
          return res.status(404).json({
            success: false,
            message: 'User not found'
          });
        }
  
        res.status(200).json({
          success: true,
          user
        });
      } catch (error) {
        next(error);
      }
    },
  
    async getAllTasks(req, res, next) {
      try {
        const tasks = await Task.find();
  
        res.status(200).json({
          success: true,
          tasks
        });
      } catch (error) {
        next(error);
      }
    },
  
    async getAllTransactions(req, res, next) {
      try {
        const transactions = await Payment.find();
  
        res.status(200).json({
          success: true,
          transactions
        });
      } catch (error) {
        next(error);
      }
    },
  
    async getDashboardStats(req, res, next) {
      try {
        const totalUsers = await User.countDocuments();
        const totalTasks = await Task.countDocuments();
        const totalRevenue = await Payment.aggregate([
          { $match: { status: 'completed' } },
          { $group: { _id: null, total: { $sum: '$amount' } } }
        ]);
  
        res.status(200).json({
          success: true,
          stats: {
            totalUsers,
            totalTasks,
            totalRevenue: totalRevenue.length ? totalRevenue[0].total : 0
          }
        });
      } catch (error) {
        next(error);
      }
    }
  }
  
